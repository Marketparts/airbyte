{
  "documentationUrl": "https://docsurl.com",
  "connectionSpecification": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "Neo4j Entity Spec",
    "type": "object",
    "required": ["scheme", "host", "port", "username", "password", "enable_dynamic_schemas"],
    "additionalProperties": false,
    "properties": {
      "scheme": {
        "description": "Uri connection scheme.",
        "type": "string",
        "enum": ["bolt", "neo4j"],
        "order": 0
      },
      "host": {
        "description": "Hostname of the database.",
        "type": "string",
        "order": 1
      },
      "port": {
        "description": "Port of the database.",
        "type": "integer",
        "minimum": 0,
        "maximum": 65536,
        "default": 7687,
        "examples": ["7687"],
        "order": 2
      },
      "database": {
        "description": "Name of the database. Leave it empty for default database or if your version of Neo4j is prior to 4.0.",
        "type": "string",
        "examples": ["neo4j"],
        "order": 3
      },
      "username": {
        "description": "Username to use to access the database.",
        "type": "string",
        "order": 4
      },
      "password": {
        "description": "Password associated with the username.",
        "type": "string",
        "airbyte_secret": true,
        "order": 5
      },
      "enable_dynamic_schemas": {
        "type": "boolean",
        "title": "Dynamically fetch node/relationship schemas from database.",
        "description": "If enabled, node/relatonship schemas are generated dynamically from a sample of the database. This query execution time depends on the volumetry of the database.",
        "order": 6,
        "default": false
      },
      "custom_streams": {
        "type": "string",
        "title": "Custom streams",
        "description": "Custom stream to sync data with cypher queries",
        "order": 7,
        "examples": ["{\"my_stream_name\": {\"match_query\": \"MATCH (A)-[:rel]->(B)\", \"return_query\": \"RETURN A, B.primary_key\", \"cursor_field\": \"A.timestamp\"}}"]
      },
      "json_schemas": {
        "type": "string",
        "title": "JSON Schemas",
        "description": "JSON Schemas for node/relationship (if auto fetch is disabled) or custom streams",
        "order": 7,
        "examples": ["{\"node_label_1\": {\"prop_1\":{\"type\":\"integer\"}}}"]
      },
      "incremental_sync_settings": {
        "type": "string",
        "title": "Incremental sync settings for streams",
        "description": "Settings for streams to be sync in incremental mode. To set default settings for all streams, user DEFAULT keyword as the stream name.",
        "order": 8,
        "examples": ["{\"DEFAULT\": {\"checkpointing_mode\": \"interval\", \"state_checkpoint_interval\": 1000}, \"my_stream_name\": {\"checkpointing_mode\": \"slices\", \"slices_count_per_incremental_sync\": 10, \"max_records_per_incremental_sync\": 1000000}}"]
      },
      "replication_method": {
        "type": "string",
        "title": "Replication Method",
        "description": "Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.",
        "order": 9,
        "default": "STANDARD",
        "enum": ["STANDARD"]
      },
      "incremental_sync_mode": {
        "type": "object",
        "title": "Incremental sync checkpointing mode",
        "description": "",
        "order": 10,
        "oneOf": [ {
          "title": "Interval-based checkpointing",
          "required": ["checkpointing_mode", "state_checkpoint_interval"],
          "properties": {
            "checkpointing_mode": {
              "type": "string",
              "const": "interval"
            },
            "state_checkpoint_interval": {
              "type": "integer",
              "title": "Number of records",
              "description": "Number of records to be read before checkpointing state",
              "order": 0,
              "default": 1000,
              "examples": [100, 1000, 2000, 5000, 10000]
            }
          }
        },
        {
          "title": "Slices",
          "required": ["slices_count_per_incremental_sync"],
          "properties": {
            "checkpointing_mode": {
              "type": "string",
              "const": "slices"
            },
            "slices_count_per_incremental_sync": {
              "type": "integer",
              "title": "Number of balanced slices",
              "description": "Number of balanced slices to generate per sync.",
              "order": 0,
              "examples": [10]
            }
          }
        }]
      },
      "max_records_per_incremental_sync": {
        "type": "integer",
        "title": "Incremental sync option: maximum number of records per sync.",
        "description": "Maximum number of records that will be read within a sync launch. Useful if you have a high volume of data but requires to run/schedule multiple syncs to synchronize all data",
        "order": 11,
        "examples": [1000000]
      }
    }
  }
}
